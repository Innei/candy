{"pageProps":{"posts":[{"title":"八月更新小记","slug":"update-2020.8","created":"2020-09-01T12:46:22.199Z","modified":"2020-09-04T16:24:25.464Z","content":"\n这是一个平平无奇的更新日志。\n\n## 前端\n\n- 重写了 Input 组件\n- 修复了 Project 页面的栅格错位\n- 其他优化\n\n## 后端\n\n- 增加了评论屏蔽关键词 （乱七八糟的内容会被吃掉哦\n- 增加了文章的 Tag\n- 增加了自动 Push Sitemap 到百度搜索联盟 （然并卵\n- 修复了自动无法删除日志的 Bug"},{"title":"七月更新小记","slug":"update-2020.7","created":"2020-07-27T05:11:45.989Z","modified":"2020-09-04T16:12:36.186Z","content":"\n暑假终于开始啦（其实已经过了好久了），相比在学校里忙忙碌碌的日子，在家每天懒懒散散，没有什么干劲可言。即便是这样，每天还是得花时间写写代码呀，当然学习一门新的语言，开辟一个新的领域也还是要跟上的。\n\n话不多说了，总结一下七月我做了哪些改进吧。\n\n**前端**\n\n- 改进了图片预览组件\n- 引入了 Sentry 异常追踪\n- 加入了友链申请框\n- 优化了某些过渡动画\n- 减少了对 antd 的组件的依赖（争取把剩下的四五个组件自己重写）\n- 重写了错误信息解析组件\n- 暂时取消了渲染服务器的缓存机制（由于前后端不在一台服务器导致的间断性请求超时 500 报错）\n- 修复了众多 bug，同时又又又加入了很多 bug\n- 部分组件的样式调整\n\n**中后台**\n\n- 等待重写至 Vue 3\n\n\n**后端**\n\n- 加入了友链申请接口\n- 重写了后端 RSS 解析接口"},{"title":"vue-next+typescript 初体验","slug":"vue-next-with-vite","created":"2020-06-05T04:49:08.448Z","modified":"2020-09-05T01:20:14.006Z","content":"\n无意间又一次刷到了尤大介绍 Vue 3 的文章，这次决定试一下 Vue 3 的 TypeScript 支持到底如何，不管别人说什么，只有自己用的舒服才是真的舒服。Vue 2 可是因为 ts 的缘故被喷的很惨，来看看 Vue 3 如何吧。\n\n> 值得注意的是，编写该篇文章时，vue 3 仍处于 beta 阶段，版本号为 `beta.14`，代码可能有变动，请关注官方和 RFC\n\n## 准备工作\n\n**注意**\n\n不要使用 vue-cli 配合 vue-cli-plugin-vue-next 来建立初始项目，该模板存在众多 bug。我遇到的问题有：\n\n- `$createElement is not defined`\n- `h is not defined`\n- `h is not function`\n\n总之无法使用 tsx，没有了 tsx 就没有灵魂了呀，这哪成啊。\n\n---\n\n使用 vite 来构建项目，官方提供了 create-vite-app 脚手架来快速构建一个新的 vue3 项目。同时也提供了 react、 react-ts、preact 的模板，全都是 out of box。感觉比得上 parcel（危）。（尤大太肝了\n\n话不多说，直接开始。\n\n```bash\nyarn create vite-app vue3-demo-vite\ncd vue3-demo-vite\ncode .\n```\n\n## 改写 TSX\n\n打开项目之后，默认使用的是 js ，但是没关系，直接安装 ts\n\n```\nyarn add -D typescript\n```\n\n无需其他配置。直接删除所有 vue 文件，新建一个 `App.tsx`\n\n声明一个组件的方式是使用 `defineComponent` 方法，目前还不知道是否支持 class component，但是可以使用 `vue-class-component` 库。这里我们就是用原生支持的函数式写法。有点类似于 React 的 FC。\n\n### 一个简单的累加器\n\n单击按钮，使得数据＋ 1.\n\n```tsx\nimport { defineComponent, ref } from 'vue'\nimport style from './index.module.css'\nexport default defineComponent({\n  name: 'Counter',\n  setup() {\n    const count = ref(0)\n\n    return () => (\n      <>\n        <button onClick={(_) => count.value++} class={style['btn']}>\n          Add\n        </button>\n        <p>{count.value}</p>\n      </>\n    )\n  },\n})\n```\n\n在 tsx 方面与 React 不同的是 `class` 和 `className`，input 的 `onChange` 和 `onInput` 。细心的你可能也会发现，tsx 方面 vue 3 几乎与 preact 一致。\n\n**注意**\n\n1. React 中的 `onInput` 和 `onChange` 有什么不同？没有不同，是一样的。但是原生事件中并不一致。[in-react-whats-the-difference-between-onchange-and-oninput](https://stackoverflow.com/questions/38256332/in-react-whats-the-difference-between-onchange-and-oninput)\n1. vite 中使用 Fragment，无需引入，如果手动引入将会报错。`Fragment is already declared.`，或者使用 `<> </>`语法糖即可。\n1. vue 3 中暂不支持子组件中需要 props 传递，同时组件使用 Fragment 包裹的情况。此时会报错。`rawChildren.filter is not a function`\n1. vite 支持 css module，但是没有声明文件，IDE 可能会报错。\n\n### Props 类型检测与完美的 TS 提示\n\n终于，组件的 Props 能被 TS 识别了！！有点激动。\n\n举个例子\n\n```tsx\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  name: 'bar',\n  props: {\n    name: {\n      type: String,\n      required: true,\n    },\n  },\n  setup(props) {\n    return () => <div>{props.name}</div>\n  },\n})\n```\n\n这是一个子组件，接收一个 `name`，并且显示该 `name`\n\n在父组件引入。\n\n![!自动导入！！！](https://cdn.jsdelivr.net/gh/innei/img-bed@master/20200605122509.png)\n\n熟悉的味道来了，Auto Import 嗒。你说写 ts 的目的是啥？\n\n![](https://cdn.jsdelivr.net/gh/innei/img-bed@master/20200605122751.png)\n\n不需要像 React 那样写 props 的 interface 了，有点小激动。\n\n### Ref\n\nvue 3 中的 `ref` 对获取 HTMLElement ref 的方法与 React 基本一致。\n\n```tsx\nimport { defineComponent, ref, watch, onMounted } from 'vue'\nexport default defineComponent({\n  name: 'Image',\n  setup() {\n    const imageRef = ref<HTMLImageElement>() // 此时为 null\n    // 挂载后获取到其Ref\n    onMounted(() => {\n      console.log(imageRef.value)\n      // do anything...\n    })\n\n    // 或者\n    watch(\n      () => imageRef.value, // 当 img ref 传递到 imageRef 时，触发，获取到其值\n      (val) => {\n        console.log(val) // 输出获取到的值\n      },\n    )\n\n    return () => {\n      return (\n        <img\n          ref={imageRef}\n          src={\n            'https://avatars0.githubusercontent.com/u/41265413?s=460&u=8c14b9682794c353995029327f439d736571426e&v=4'\n          }\n        />\n      )\n    }\n  },\n})\n```\n\n### Lifecircle\n\nvue 3 中生命周期全部为 hook 的形式，也就是可以多次叠加触发。一个生命周期钩子可以定义多次，按顺序执行。\n\n```tsx\nimport { defineComponent, onMounted, ref } from 'vue'\n\nexport default defineComponent({\n  name: 'lifecircle',\n  setup() {\n    const message = ref('')\n    onMounted(() => {\n      message.value = message.value + '我触发了一次'\n    })\n    onMounted(() => {\n      message.value = message.value + '\\n我又触发了一次'\n    })\n\n    return () => (\n      <>\n        this is lifecircle component.\n        <pre>{message.value}</pre>\n      </>\n    )\n  },\n})\n```\n\n![](https://cdn.jsdelivr.net/gh/innei/img-bed@master/20200605124736.png)\n\n### 计算属性\n\n通过 `computed` 方法包装获得计算属性。\n\n```tsx\nimport { defineComponent, ref, computed } from 'vue'\nimport style from './index.module.css'\nexport default defineComponent({\n  name: 'Counter',\n  setup() {\n    const count = ref(0)\n    const double = computed(() => count.value * 2) // 包装一个计算属性，value 为计算的值\n    return () => (\n      <>\n        <button onClick={(_) => count.value++} class={style['btn']}>\n          Add\n        </button>\n        <p>{count.value}</p>\n        <p>doubled: {double.value}</p>\n      </>\n    )\n  },\n})\n\n```"},{"title":"折腾失败的新主题","slug":"折腾失败的新主题","created":"2019-01-25T04:58:00.000Z","modified":"2020-08-24T03:23:54.894Z","content":"\n记2019年1月25日\r\n\r\n博客从Next主题更换为更为简洁的polarbear\r\n\r\n因为太简洁了, 所以我想把原先的统计信息与评论系统加入.\r\n\r\n再折腾很久的layout, 甚至直接导入appid, 放入layout.swig还是失败了.\r\n\r\n所以说现在这个博客是空无一物.\r\n\r\n可能以后我会换回Next的吧."},{"title":"使用图床,为GP节省空间","slug":"使用sm-ms图床-为GP节省空间","created":"2018-09-07T08:04:00.000Z","modified":"2020-08-28T13:14:47.711Z","content":"\n## 图床是什么\r\n图床一般是指储存图片的服务器，有国内和国外之分。 国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。 国内也分为单线空间、多线空间和cdn加速三种。\r\n\r\n## 使用图床\r\nsm.ms是一个比较好的免费图床.\r\n这里我以上传到 https://sm.ms/ 这个图床做为说明，它的 API 文档为：https://sm.ms/doc/\r\n## 如何配置\r\n这里以MWeb为例\r\n![](https://i.loli.net/2018/09/07/5b9231f29a3e3.jpg)\r\n\r\n>[iOS 版 MWeb 图床功能中自定义图床的使用指南](https://zh.mweb.im/how_to_use_custom_image_upload_url.html)"}],"query":{"currentPage":1,"hasNext":false,"hasPrev":false,"size":10,"totalPage":1}},"__N_SSG":true}