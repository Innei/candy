{"pageProps":{"title":"vue-next+typescript 初体验","slug":"vue-next-with-vite","created":"2020-06-05T04:49:08.448Z","modified":"2020-09-05T01:20:14.006Z","content":"\n无意间又一次刷到了尤大介绍 Vue 3 的文章，这次决定试一下 Vue 3 的 TypeScript 支持到底如何，不管别人说什么，只有自己用的舒服才是真的舒服。Vue 2 可是因为 ts 的缘故被喷的很惨，来看看 Vue 3 如何吧。\n\n> 值得注意的是，编写该篇文章时，vue 3 仍处于 beta 阶段，版本号为 `beta.14`，代码可能有变动，请关注官方和 RFC\n\n## 准备工作\n\n**注意**\n\n不要使用 vue-cli 配合 vue-cli-plugin-vue-next 来建立初始项目，该模板存在众多 bug。我遇到的问题有：\n\n- `$createElement is not defined`\n- `h is not defined`\n- `h is not function`\n\n总之无法使用 tsx，没有了 tsx 就没有灵魂了呀，这哪成啊。\n\n---\n\n使用 vite 来构建项目，官方提供了 create-vite-app 脚手架来快速构建一个新的 vue3 项目。同时也提供了 react、 react-ts、preact 的模板，全都是 out of box。感觉比得上 parcel（危）。（尤大太肝了\n\n话不多说，直接开始。\n\n```bash\nyarn create vite-app vue3-demo-vite\ncd vue3-demo-vite\ncode .\n```\n\n## 改写 TSX\n\n打开项目之后，默认使用的是 js ，但是没关系，直接安装 ts\n\n```\nyarn add -D typescript\n```\n\n无需其他配置。直接删除所有 vue 文件，新建一个 `App.tsx`\n\n声明一个组件的方式是使用 `defineComponent` 方法，目前还不知道是否支持 class component，但是可以使用 `vue-class-component` 库。这里我们就是用原生支持的函数式写法。有点类似于 React 的 FC。\n\n### 一个简单的累加器\n\n单击按钮，使得数据＋ 1.\n\n```tsx\nimport { defineComponent, ref } from 'vue'\nimport style from './index.module.css'\nexport default defineComponent({\n  name: 'Counter',\n  setup() {\n    const count = ref(0)\n\n    return () => (\n      <>\n        <button onClick={(_) => count.value++} class={style['btn']}>\n          Add\n        </button>\n        <p>{count.value}</p>\n      </>\n    )\n  },\n})\n```\n\n在 tsx 方面与 React 不同的是 `class` 和 `className`，input 的 `onChange` 和 `onInput` 。细心的你可能也会发现，tsx 方面 vue 3 几乎与 preact 一致。\n\n**注意**\n\n1. React 中的 `onInput` 和 `onChange` 有什么不同？没有不同，是一样的。但是原生事件中并不一致。[in-react-whats-the-difference-between-onchange-and-oninput](https://stackoverflow.com/questions/38256332/in-react-whats-the-difference-between-onchange-and-oninput)\n1. vite 中使用 Fragment，无需引入，如果手动引入将会报错。`Fragment is already declared.`，或者使用 `<> </>`语法糖即可。\n1. vue 3 中暂不支持子组件中需要 props 传递，同时组件使用 Fragment 包裹的情况。此时会报错。`rawChildren.filter is not a function`\n1. vite 支持 css module，但是没有声明文件，IDE 可能会报错。\n\n### Props 类型检测与完美的 TS 提示\n\n终于，组件的 Props 能被 TS 识别了！！有点激动。\n\n举个例子\n\n```tsx\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  name: 'bar',\n  props: {\n    name: {\n      type: String,\n      required: true,\n    },\n  },\n  setup(props) {\n    return () => <div>{props.name}</div>\n  },\n})\n```\n\n这是一个子组件，接收一个 `name`，并且显示该 `name`\n\n在父组件引入。\n\n![!自动导入！！！](https://cdn.jsdelivr.net/gh/innei/img-bed@master/20200605122509.png)\n\n熟悉的味道来了，Auto Import 嗒。你说写 ts 的目的是啥？\n\n![](https://cdn.jsdelivr.net/gh/innei/img-bed@master/20200605122751.png)\n\n不需要像 React 那样写 props 的 interface 了，有点小激动。\n\n### Ref\n\nvue 3 中的 `ref` 对获取 HTMLElement ref 的方法与 React 基本一致。\n\n```tsx\nimport { defineComponent, ref, watch, onMounted } from 'vue'\nexport default defineComponent({\n  name: 'Image',\n  setup() {\n    const imageRef = ref<HTMLImageElement>() // 此时为 null\n    // 挂载后获取到其Ref\n    onMounted(() => {\n      console.log(imageRef.value)\n      // do anything...\n    })\n\n    // 或者\n    watch(\n      () => imageRef.value, // 当 img ref 传递到 imageRef 时，触发，获取到其值\n      (val) => {\n        console.log(val) // 输出获取到的值\n      },\n    )\n\n    return () => {\n      return (\n        <img\n          ref={imageRef}\n          src={\n            'https://avatars0.githubusercontent.com/u/41265413?s=460&u=8c14b9682794c353995029327f439d736571426e&v=4'\n          }\n        />\n      )\n    }\n  },\n})\n```\n\n### Lifecircle\n\nvue 3 中生命周期全部为 hook 的形式，也就是可以多次叠加触发。一个生命周期钩子可以定义多次，按顺序执行。\n\n```tsx\nimport { defineComponent, onMounted, ref } from 'vue'\n\nexport default defineComponent({\n  name: 'lifecircle',\n  setup() {\n    const message = ref('')\n    onMounted(() => {\n      message.value = message.value + '我触发了一次'\n    })\n    onMounted(() => {\n      message.value = message.value + '\\n我又触发了一次'\n    })\n\n    return () => (\n      <>\n        this is lifecircle component.\n        <pre>{message.value}</pre>\n      </>\n    )\n  },\n})\n```\n\n![](https://cdn.jsdelivr.net/gh/innei/img-bed@master/20200605124736.png)\n\n### 计算属性\n\n通过 `computed` 方法包装获得计算属性。\n\n```tsx\nimport { defineComponent, ref, computed } from 'vue'\nimport style from './index.module.css'\nexport default defineComponent({\n  name: 'Counter',\n  setup() {\n    const count = ref(0)\n    const double = computed(() => count.value * 2) // 包装一个计算属性，value 为计算的值\n    return () => (\n      <>\n        <button onClick={(_) => count.value++} class={style['btn']}>\n          Add\n        </button>\n        <p>{count.value}</p>\n        <p>doubled: {double.value}</p>\n      </>\n    )\n  },\n})\n\n```"},"__N_SSG":true}